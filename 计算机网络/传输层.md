<a name="ZEpOL"></a>
# TCP三次握手和四次挥手
为了准确无误将数据送达目标处，TCP协议采用了三次握手策略。
<a name="mIAqd"></a>
## 建立连接-TCP 三次握手
建立一个TCP连接需要”三次握手“，缺一不可：

- **一次握手：**客户端发送带有`SYN（SEQ=x）`标志的数据报 -> 服务端，然后客户端进入`SYN_SEND`状态，等待服务器的确认。
- 二次握手：服务器端发送带有`SYN+ACK(SEQ=y,ACK=x+1)`标志的数据报 -> 客户端，然后服务端进入`SYN_RECV`状态。
- **三次握手：**客户端发送带有`ACK（ACK = y+1）`标志的数据报 -> 服务端，然后客户端和服务端都进入`ESTABLISHED`状态，完成TCP三次握手。

当建立了三次握手之后，客户端和服务端就可以传输数据啦！
<a name="t86IO"></a>
### 为什么要三次握手？
三次握手的目的是简历可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。

1. **第一次握手：**`Client`什么都不能确认；`Server`确认了对方发送正常，自己接受正常。
2. **第二次握手：**`Client`确认了：自己发送、接受正常，对方发送、接受正常；`Server`确认了：对方发送正常，自己接受正常
3. **第三次握手：**`Client`确认了：自己发送、接受正常，对方发送、接受正常；`Server`确认了：自己发送、接受正常，对方发送、接受正常。

三次握手就能确认双方收发功能都能正常，缺一不可。
<a name="K7q2K"></a>
### 第二次握手传回了ACK，为什么还要穿会SYN？
服务端传回发送端所发送的ACK是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传SYN则是为了建立并确认从服务端到客户端的通信。<br />SYN同步序列编号（Synchronize Sequence Numbers）是TCP/IP建立连接时使用的握手信号。在客户机和服务器之间建立正常的TCP网络连接时，客户机首先发出一个SYN消息，服务器使用SYN-ACK应答表示接收到了这个消息，最后客户机再以ACK（Acknowledgement）消息响应。这样再客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。
<a name="ugio3"></a>
## 断开连接-TCP四次挥手
断开一个TCP连接需要“四次挥手”，缺一不可。

1. **第一次回收：**客户端发送一个`FIN（SEQ=X）`标志的数据报 -> 服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入`FIN-WAIT-1`状态。
2. **第二次挥手：**服务器收到这个`FIN（SEQ=X）`标志的数据报，他发送一个`ACK（SEQ=X+1）`标志的数据报 -> 客户端。然后，此时服务端进入`CLOSE-WAIT`状态，客户端进入`FIN-WAIT-2`状态。
3. **第三次挥手：**服务端关闭与客户端的连接并发送一个`FIN（SEQ=y）`标志的数据报 -> 客户端请求关闭连接，然后，服务端进入`LAST-ACK`状态。
4. **第四次挥手：**客户端发送`ACK（SEQ=y+1）`标志的数据报 -> 服务端并且进入`TIME-WAIT`状态，服务端在收到`ACK（SEQ=y+1）`标志的数据报后进入`CLOSE`状态。此时，如果客户端等待`2MSL`后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。

只要四次挥手没有结束，客户端和服务端就可以继续传输数据！
<a name="WAFfj"></a>
### 为什么要四次挥手？
TCP是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送时，则发出连接释放通知，对方确认后就完全关闭了TCP连接。
<a name="w24Y9"></a>
### 为什么不能把服务器发送的ACK和FIN合并起来，变成三次挥手？
因为服务器收到客户端断开连接的请求时，可能还有一些数据没有发完，这时先回复ACK，表示接受到了断开连接的请求。等到数据发完之后再发FIN，断开服务器到客户端的数据传送。
<a name="SqUn7"></a>
### 如果第二次挥手时服务器的ACK没有送达客户端，会怎样？
客户端没有收到ACK确认，会重新发送FIN请求。
<a name="C7Tfg"></a>
### 为什么第四次挥手客户端需要等待2*MSL（报文段最长寿命）时间后才进入CLOSE状态？
第四次挥手时，客户端发送给服务器的ACK有可能丢失，如果服务端因为某些原因而没有收到ACK的话，服务端就会重发FIN，如果客户端在2*MSL的时间内收到了FIN，就会重新发送ACK并再次等待2*MSL，防止Server没有收到ACK而不断重发FIN。<br />MSL（Maximum Segment Lifetime）：一个片段在网络中最大的存活时间，2MSL就是要给发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。
